<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¯­éŸ³æ‹¼å†™ç”Ÿè¯æœ¬ v2.1.0</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; max-width: 500px; margin: 0 auto; padding: 20px; background: #f4f7f6; color: #333; }
        .card { background: white; padding: 25px 20px; border-radius: 16px; box-shadow: 0 8px 20px rgba(0,0,0,0.06); margin-bottom: 20px; text-align: center; }
        h2 { margin-top: 0; font-size: 20px; color: #1c1c1e; display: flex; justify-content: space-between; align-items: center;}
        .version-tag { font-size: 12px; background: #e0e0e0; padding: 2px 8px; border-radius: 10px; color: #555; font-weight: normal; }
        
        #recordBtn { background: #007aff; color: white; border: none; padding: 16px 30px; font-size: 18px; font-weight: 600; border-radius: 50px; cursor: pointer; user-select: none; transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1); width: 100%; box-shadow: 0 4px 12px rgba(0,122,255,0.3); -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent;}
        #recordBtn:active { transform: scale(0.96); }
        #recordBtn.recording { background: #ff3b30; box-shadow: 0 4px 12px rgba(255,59,48,0.4); animation: pulse 1.5s infinite; }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255,59,48, 0.4); }
            70% { box-shadow: 0 0 0 12px rgba(255,59,48, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255,59,48, 0); }
        }

        #exportBtn { background: #34c759; color: white; border: none; padding: 8px 15px; font-size: 14px; font-weight: 600; border-radius: 8px; cursor: pointer; transition: opacity 0.2s; }
        #exportBtn:active { opacity: 0.7; }

        .status { margin-top: 15px; font-size: 14px; color: #8e8e93; min-height: 20px; font-weight: 500; }
        #rawTranscript { margin-top: 8px; font-size: 13px; color: #d09a00; display: block; min-height: 15px; }
        #resultWord { font-size: 40px; font-weight: 800; margin: 15px 0; color: #1c1c1e; letter-spacing: 2px; }
        #meaning { font-size: 15px; color: #3a3a3c; min-height: 45px; background: #f2f2f7; padding: 12px; border-radius: 12px; line-height: 1.5;}
        
        .input-group { text-align: left; margin-bottom: 20px; }
        label { font-size: 14px; font-weight: 600; color: #636366; display: block; margin-bottom: 8px; }
        input[type="text"] { width: 100%; padding: 12px; border: 1px solid #d1d1d6; border-radius: 10px; box-sizing: border-box; font-size: 16px; transition: border-color 0.2s; outline: none; }
        input[type="text"]:focus { border-color: #007aff; }
        
        .word-list { text-align: left; }
        .archive-group { margin-top: 20px; }
        .archive-header { background: #f2f2f7; padding: 10px 15px; border-radius: 10px; font-weight: 700; font-size: 15px; color: #1c1c1e; display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;}
        .word-item { padding: 12px 10px; border-bottom: 1px solid #e5e5ea; display: flex; flex-direction: column;}
        .word-item:last-child { border-bottom: none; }
        .word-word { font-size: 18px; font-weight: 700; color: #007aff; }
        .word-meaning { font-size: 14px; color: #636366; margin-top: 6px; }
    </style>
</head>
<body>

    <div class="card">
        <h2>
            ğŸ™ï¸ ç‚¹å‡»è¯»å­—æ¯æ‹¼å†™
            <span class="version-tag">v2.1.0-Pro</span>
        </h2>
        
        <div class="input-group">
            <label for="archiveName">å½’æ¡£åç§° (å¯ä¿®æ”¹ä¸ºä¹¦å/ç« èŠ‚):</label>
            <input type="text" id="archiveName" placeholder="ä¾‹å¦‚: 2026-02-20 æˆ– ç®€çˆ±-ç¬¬ä¸€ç« ">
        </div>

        <button id="recordBtn">ğŸ™ï¸ ç‚¹å‡»å¼€å§‹æ‹¼å†™å­—æ¯</button>
        <div class="status" id="statusText">å‡†å¤‡å°±ç»ª...</div>
        <!-- å¢åŠ ä¸€ä¸ªè°ƒè¯•å±‚ï¼Œæ˜¾ç¤ºçœŸæ­£å¬åˆ°çš„å†…å®¹ -->
        <div id="rawTranscript"></div>
        
        <div id="resultWord">...</div>
        <div id="meaning">ç­‰å¾…æŸ¥è¯...</div>
    </div>

    <div class="card word-list">
        <h2>
            ğŸ“š ä½ çš„ç”Ÿè¯æœ¬
            <button id="exportBtn">ğŸ’¾ å¯¼å‡º CSV</button>
        </h2>
        <div id="vocabList"></div>
    </div>

    <script>
        // åˆå§‹åŒ–æ—¥æœŸä½œä¸ºé»˜è®¤å½’æ¡£å
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('archiveName').value = today;

        const recordBtn = document.getElementById('recordBtn');
        const exportBtn = document.getElementById('exportBtn');
        const statusText = document.getElementById('statusText');
        const rawTranscriptDisplay = document.getElementById('rawTranscript');
        const resultWordDisplay = document.getElementById('resultWord');
        const meaningDisplay = document.getElementById('meaning');
        const vocabListDisplay = document.getElementById('vocabList');

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;
        let isRecording = false;

        // ã€æ ¸å¿ƒä¿®å¤ 1ã€‘å½»åº•æ€æ‰åƒµå°¸å®ä¾‹ï¼Œé˜²æ­¢ iOS Safari éº¦å…‹é£é€šé“å µå¡
        function killZombieRecognition() {
            if (recognition) {
                // 1. æ‘˜é™¤æ‰€æœ‰äº‹ä»¶é’©å­ï¼Œé˜²æ­¢æ—§å®ä¾‹è§¦å‘å›è°ƒå¯¼è‡´çŠ¶æ€æ··ä¹±
                recognition.onstart = null;
                recognition.onresult = null;
                recognition.onerror = null;
                recognition.onend = null;
                recognition.onspeechend = null;
                // 2. å¼ºè¡Œç»ˆæ­¢
                try { recognition.abort(); } catch (e) {}
                // 3. å†…å­˜å›æ”¶
                recognition = null;
            }
        }

        // åˆ‡æ¢å½•éŸ³çŠ¶æ€
        function toggleRecording(e) {
            e.preventDefault();

            // å¦‚æœæ­£åœ¨å½•éŸ³ï¼Œç‚¹å‡»åˆ™æ‰‹åŠ¨åœæ­¢å¹¶å¼€å§‹è§£æï¼ˆé€‚é…iOSæœ‰æ—¶ç­‰ä¸åˆ°é™éŸ³çš„æƒ…å†µï¼‰
            if (isRecording && recognition) {
                try { recognition.stop(); } catch (e) {}
                isRecording = false;
                recordBtn.classList.remove('recording');
                recordBtn.innerText = "ğŸ™ï¸ ç‚¹å‡»å¼€å§‹æ‹¼å†™å­—æ¯";
                statusText.innerText = "å·²æ‰‹åŠ¨ç»“æŸï¼Œå¤„ç†ä¸­...";
                return;
            }

            // ã€å¼€å§‹å…¨æ–°å½•éŸ³ã€‘
            if (!SpeechRecognition) {
                statusText.innerText = "âŒ ä½ çš„æµè§ˆå™¨ä¸æ”¯æŒï¼Œè¯·ä½¿ç”¨ Safari æˆ– Chromeã€‚";
                return;
            }

            // æ¯æ¬¡å¯åŠ¨å‰å…ˆæ¸…åœº
            killZombieRecognition();
            rawTranscriptDisplay.innerText = ""; // æ¸…ç©ºä¸Šæ¬¡çš„è°ƒè¯•è®°å½•

            // åˆ›å»ºçº¯å‡€çš„æ–°å®ä¾‹
            recognition = new SpeechRecognition();
            recognition.lang = 'en-US'; 
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;
            recognition.continuous = false; // iOS å¿…é¡»è®¾ä¸º falseï¼Œå¦åˆ™å®¹æ˜“å´©æºƒ

            recognition.onstart = () => {
                isRecording = true;
                recordBtn.classList.add('recording');
                recordBtn.innerText = "ğŸ›‘ æ­£åœ¨è†å¬... (è¯´å®Œå¯å†ç‚¹ä¸€æ¬¡ç»“æŸ)";
                statusText.innerText = "è¯·è¯»å‡ºå­—æ¯ (ä¾‹å¦‚è¯» 'A P P L E')...";
            };

            // å½“ç³»ç»Ÿæ£€æµ‹åˆ°ä½ åœæ­¢è¯´è¯
            recognition.onspeechend = () => {
                statusText.innerText = "æ£€æµ‹åˆ°åœé¡¿ï¼Œæ­£åœ¨å‘ Apple æœåŠ¡å™¨è¯·æ±‚ç»“æœ...";
            };

            recognition.onresult = async (event) => {
                const transcript = event.results[0][0].transcript;
                
                // ã€æ ¸å¿ƒä¿®å¤ 2ã€‘æŠŠåŸå§‹è¯†åˆ«ç»“æœæ˜¾ç¤ºå‡ºæ¥ï¼Œæ–¹ä¾¿è¯Šæ–­é—®é¢˜
                rawTranscriptDisplay.innerText = `[åº•å±‚å¬åˆ°å†…å®¹]: "${transcript}"`;
                
                // å»æ‰ç©ºæ ¼å’Œæ ‡ç‚¹ç¬¦å·ï¼Œåªä¿ç•™çº¯å­—æ¯
                const word = transcript.replace(/[^a-zA-Z]/g, '').toLowerCase();
                
                if (!word) {
                    statusText.innerText = "âš ï¸ è­¦å‘Šï¼šæœªè¯†åˆ«å‡ºä»»ä½•è‹±æ–‡å­—æ¯ã€‚";
                    resultWordDisplay.innerText = "æœªè¯†åˆ«";
                    meaningDisplay.innerText = "è¯·æ£€æŸ¥åˆšæ‰ã€åº•å±‚å¬åˆ°å†…å®¹ã€‘ä¸­æ˜¯å¦åŒ…å«å­—æ¯ï¼Œå¯ä»¥è¯•ç€å‘éŸ³æ›´å¹²è„†ä¸€äº›ã€‚";
                    return;
                }

                resultWordDisplay.innerText = word;
                statusText.innerText = "æ­£åœ¨æŸ¥è¯¢å­—å…¸...";
                meaningDisplay.innerText = "æŸ¥è¯¢ä¸­...";

                await processWord(word);
            };

            recognition.onerror = (event) => {
                console.error("åº•å±‚è¯†åˆ«é”™è¯¯ä»£ç :", event.error);
                
                // å‹å¥½çš„ä¸­æ–‡é”™è¯¯æç¤ºæ˜ å°„
                const errorMap = {
                    'network': "ç½‘ç»œä¸ä½³ï¼šæ— æ³•è¿æ¥åˆ° Apple å¬å†™æœåŠ¡å™¨ã€‚",
                    'not-allowed': "æƒé™æ‹’ç»ï¼šè¯·åœ¨ Safari è®¾ç½®ä¸­å…è®¸éº¦å…‹é£æƒé™ã€‚",
                    'no-speech': "é™éŸ³è¶…æ—¶ï¼šæ²¡å¬åˆ°å£°éŸ³ï¼Œè¯·å¤§ç‚¹å£°æˆ–é è¿›éº¦å…‹é£ã€‚",
                    'service-not-allowed': "æœåŠ¡ç¦ç”¨ï¼šè¯·åœ¨ã€è®¾ç½®-é€šç”¨-é”®ç›˜-å¯ç”¨å¬å†™ã€‘ä¸­å¼€å¯ã€‚",
                    'aborted': "è¯†åˆ«è¢«æ„å¤–ç»ˆæ­¢ã€‚"
                };
                
                statusText.innerText = "âŒ é”™è¯¯: " + (errorMap[event.error] || event.error);
            };

            recognition.onend = () => {
                isRecording = false;
                recordBtn.classList.remove('recording');
                recordBtn.innerText = "ğŸ™ï¸ ç‚¹å‡»å¼€å§‹æ‹¼å†™å­—æ¯";
                // å¦‚æœæ²¡æœ‰è§¦å‘ onresult ç›´æ¥ç»“æŸäº†ï¼ˆé€šå¸¸æ˜¯å› ä¸ºæ²¡è¯´è¯æˆ–å…¨èƒŒæ™¯å™ªéŸ³ï¼‰
                if(statusText.innerText.includes("è¯·è¯»å‡ºå­—æ¯") || statusText.innerText.includes("æ£€æµ‹åˆ°åœé¡¿")) {
                    statusText.innerText = "è¯†åˆ«è‡ªåŠ¨ç»“æŸ (æœªæ•æ‰åˆ°æœ‰æ•ˆå£°éŸ³)ã€‚";
                }
            };

            try {
                recognition.start();
            } catch (err) {
                console.error("å”¤é†’éº¦å…‹é£å¼‚å¸¸:", err);
                isRecording = false;
                statusText.innerText = "âŒ å¯åŠ¨éº¦å…‹é£å¤±è´¥ï¼Œè¯·å°è¯•åˆ·æ–°ç½‘é¡µã€‚";
                killZombieRecognition();
            }
        }

        // ç»‘å®šç‚¹å‡»äº‹ä»¶ (iOS ä¸‹å•çº¯çš„ click æ¯” mousedown/touchstart å…¼å®¹æ€§æ›´å¥½)
        recordBtn.addEventListener('click', toggleRecording);

        // å¤„ç†å•è¯ï¼šæŸ¥è¯¢é‡Šä¹‰å¹¶ä¿å­˜
        async function processWord(word) {
            let meaning = "æš‚æ— é‡Šä¹‰ï¼Œå¯èƒ½æ‹¼å†™æœ‰è¯¯æˆ–å­—å…¸æœªæ”¶å½•ã€‚";
            
            try {
                // ä½¿ç”¨å…¬å…±å…è´¹å­—å…¸ API
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (response.ok) {
                    const data = await response.json();
                    meaning = data[0].meanings[0].definitions[0].definition;
                    statusText.innerText = "âœ… æŸ¥è¯¢æˆåŠŸï¼";
                } else {
                    statusText.innerText = "âš ï¸ å­—å…¸ä¸­æœªæ‰¾åˆ°è¯¥è¯ã€‚";
                }
            } catch (error) {
                console.error("æŸ¥è¯ç½‘ç»œé”™è¯¯:", error);
                meaning = "ç½‘ç»œé”™è¯¯ï¼Œæ— æ³•è¿æ¥åˆ°å­—å…¸æœåŠ¡å™¨è·å–é‡Šä¹‰ã€‚";
                statusText.innerText = "âŒ æŸ¥è¯è¯·æ±‚å¤±è´¥";
            }

            meaningDisplay.innerText = meaning;
            saveWord(word, meaning);
            renderVocabList();
        }

        // ä¿å­˜å•è¯åˆ° LocalStorage
        function saveWord(word, meaning) {
            const archiveName = document.getElementById('archiveName').value || today;
            let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            
            if (!vocabData[archiveName]) {
                vocabData[archiveName] = [];
            }
            
            // æŸ¥é‡å¹¶æ’å…¥æœ€å‰é¢
            const exists = vocabData[archiveName].find(w => w.word === word);
            if (!exists) {
                vocabData[archiveName].unshift({ word, meaning });
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
            }
        }

        // æ¸²æŸ“ç”Ÿè¯åˆ—è¡¨
        function renderVocabList() {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            vocabListDisplay.innerHTML = '';

            for (const archive in vocabData) {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'archive-group';
                
                const header = document.createElement('div');
                header.className = 'archive-header';
                header.innerHTML = `<span>ğŸ“‚ ${archive}</span> <span style="font-size: 13px; color: #8e8e93; font-weight: normal;">${vocabData[archive].length} è¯</span>`;
                groupDiv.appendChild(header);

                vocabData[archive].forEach(item => {
                    const wordDiv = document.createElement('div');
                    wordDiv.className = 'word-item';
                    wordDiv.innerHTML = `
                        <span class="word-word">${item.word}</span>
                        <span class="word-meaning">${item.meaning}</span>
                    `;
                    groupDiv.appendChild(wordDiv);
                });

                vocabListDisplay.appendChild(groupDiv);
            }
        }

        // å¯¼å‡ºä¸º CSV åŠŸèƒ½
        exportBtn.addEventListener('click', () => {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if (Object.keys(vocabData).length === 0) {
                alert("ç”Ÿè¯æœ¬æ˜¯ç©ºçš„ï¼Œå…ˆå»å½•å…¥å‡ ä¸ªå•è¯å§ï¼");
                return;
            }

            let csvContent = "\uFEFFå½’æ¡£åç§°,å•è¯,é‡Šä¹‰\n";

            for (const archive in vocabData) {
                vocabData[archive].forEach(item => {
                    let safeMeaning = item.meaning.replace(/"/g, '""');
                    csvContent += `"${archive}","${item.word}","${safeMeaning}"\n`;
                });
            }

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            link.setAttribute("download", `ç”Ÿè¯æœ¬_${today}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // åˆå§‹åŒ–æ¸²æŸ“
        renderVocabList();
    </script>
</body>
</html>
