<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¯­éŸ³æ‹¼å†™ç”Ÿè¯æœ¬ v4.0.0</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; max-width: 500px; margin: 0 auto; padding: 20px; background: #f4f7f6; color: #333; }
        .card { background: white; padding: 25px 20px; border-radius: 16px; box-shadow: 0 8px 20px rgba(0,0,0,0.06); margin-bottom: 20px; text-align: center; }
        h2 { margin-top: 0; font-size: 20px; color: #1c1c1e; display: flex; justify-content: space-between; align-items: center;}
        .version-tag { font-size: 12px; background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); padding: 3px 10px; border-radius: 12px; color: #fff; font-weight: bold; letter-spacing: 0.5px;}
        
        #recordBtn { background: #007aff; color: white; border: none; padding: 18px 30px; font-size: 18px; font-weight: 600; border-radius: 50px; cursor: pointer; user-select: none; transition: all 0.2s; width: 100%; box-shadow: 0 4px 12px rgba(0,122,255,0.3); -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent;}
        #recordBtn.recording { background: #ff3b30; box-shadow: 0 4px 12px rgba(255,59,48,0.4); transform: scale(0.96); }
        #recordBtn.busy { background: #ff9500; box-shadow: 0 4px 12px rgba(255,149,0,0.4); pointer-events: none; transform: none; }

        .btn-export-all { background: #34c759; color: white; border: none; padding: 8px 15px; font-size: 14px; font-weight: 600; border-radius: 8px; cursor: pointer; }
        
        .status { margin-top: 15px; font-size: 14px; color: #8e8e93; min-height: 20px; font-weight: 500; }
        #rawTranscript { margin-top: 8px; font-size: 13px; color: #ff9500; display: block; min-height: 15px; font-weight: bold;}
        #resultWord { font-size: 40px; font-weight: 800; margin: 15px 0; color: #1c1c1e; letter-spacing: 2px; }
        #meaning { font-size: 15px; color: #3a3a3c; min-height: 45px; background: #f2f2f7; padding: 12px; border-radius: 12px; line-height: 1.5; text-align: left;}
        .cn-meaning { color: #d9534f; font-weight: bold; margin-bottom: 5px; display: block; }
        
        .input-group { text-align: left; margin-bottom: 20px; }
        label { font-size: 14px; font-weight: 600; color: #636366; display: block; margin-bottom: 8px; }
        input[type="text"] { width: 100%; padding: 12px; border: 1px solid #d1d1d6; border-radius: 10px; box-sizing: border-box; font-size: 16px; outline: none; }
        
        .word-list { text-align: left; }
        .archive-group { margin-top: 25px; border: 1px solid #e5e5ea; border-radius: 12px; overflow: hidden; }
        .archive-header { background: #f8f8f8; padding: 12px 15px; font-weight: 700; font-size: 15px; color: #1c1c1e; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #e5e5ea;}
        .archive-title { flex: 1; display: flex; align-items: center; gap: 5px; }
        .archive-actions { display: flex; gap: 8px; }
        
        .word-item { padding: 15px; border-bottom: 1px solid #f2f2f7; display: flex; justify-content: space-between; align-items: flex-start;}
        .word-item:last-child { border-bottom: none; }
        .word-content { display: flex; flex-direction: column; flex: 1; margin-right: 10px; }
        .word-header { display: flex; align-items: center; gap: 8px; }
        .word-word { font-size: 18px; font-weight: 700; color: #007aff; }
        
        .audio-btn { background: #e5f1ff; color: #007aff; border: none; border-radius: 50%; width: 26px; height: 26px; display: flex; align-items: center; justify-content: center; font-size: 12px; cursor: pointer; }
        .audio-btn:active { transform: scale(0.9); }
        
        .word-meaning { font-size: 14px; color: #636366; margin-top: 6px; line-height: 1.5; }
        .word-meaning-cn { color: #d9534f; font-weight: 600; margin-bottom: 3px; }
        
        .action-btns { display: flex; gap: 5px; }
        .icon-btn { background: #f2f2f7; border: none; font-size: 14px; cursor: pointer; padding: 6px 10px; border-radius: 8px; transition: background 0.2s; -webkit-tap-highlight-color: transparent; }
        .icon-btn:active { background: #e5e5ea; }
        .icon-btn.danger:active { background: #ffe5e5; color: red;}
    </style>
</head>
<body>

    <div class="card">
        <h2>
            ğŸ™ï¸ è¯­éŸ³æ‹¼å†™ç”Ÿè¯æœ¬
            <span class="version-tag">v4.0.0-Master</span>
        </h2>
        
        <div class="input-group">
            <label for="archiveName">å½’æ¡£åç§° (å¯ä¿®æ”¹ä¸ºä¹¦å/ç« èŠ‚):</label>
            <input type="text" id="archiveName" placeholder="ä¾‹å¦‚: 2026-02-20">
        </div>

        <button id="recordBtn">æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯</button>
        <div class="status" id="statusText">å‡†å¤‡å°±ç»ª...</div>
        <div id="rawTranscript"></div>
        
        <div id="resultWord">...</div>
        <div id="meaning">çŸ­è¯­ä¸­æœ‰ç©ºæ ¼æ—¶ï¼Œè¯·è¯» "space"</div>
    </div>

    <div class="card word-list">
        <h2>
            ğŸ“š ä½ çš„ç”Ÿè¯æœ¬
            <button id="exportBtn" class="btn-export-all">ğŸ’¾ å¯¼å‡ºå…¨éƒ¨</button>
        </h2>
        <div id="vocabList"></div>
    </div>

    <script>
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('archiveName').value = today;

        const recordBtn = document.getElementById('recordBtn');
        const exportBtn = document.getElementById('exportBtn');
        const statusText = document.getElementById('statusText');
        const rawTranscriptDisplay = document.getElementById('rawTranscript');
        const resultWordDisplay = document.getElementById('resultWord');
        const meaningDisplay = document.getElementById('meaning');
        const vocabListDisplay = document.getElementById('vocabList');

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;
        
        let isSystemBusy = false; 
        let fallbackTimer = null; 
        let hasActuallyStarted = false; 

        function resetRecognition() {
            if (recognition) {
                recognition.onstart = null;
                recognition.onresult = null;
                recognition.onerror = null;
                recognition.onend = null;
                try { recognition.abort(); } catch(e){}
                recognition = null;
            }
            clearTimeout(fallbackTimer);
        }

        const startRecording = (e) => {
            e.preventDefault();
            if (isSystemBusy) return; 
            
            isSystemBusy = true;
            hasActuallyStarted = false; 
            rawTranscriptDisplay.innerText = "";
            resetRecognition();

            if (!SpeechRecognition) {
                statusText.innerText = "âŒ æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«ã€‚";
                isSystemBusy = false;
                return;
            }

            recognition = new SpeechRecognition();
            recognition.lang = 'en-US'; 
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;
            recognition.continuous = false;

            recognition.onstart = () => {
                hasActuallyStarted = true; 
                recordBtn.classList.add('recording');
                recordBtn.innerText = "ğŸ›‘ æ­£åœ¨è†å¬... (çŸ­è¯­è¯·åŠ è¯» space)";
                statusText.innerText = "è¯·å¼€å§‹æ‹¼è¯»å­—æ¯...";
            };

            recognition.onresult = async (event) => {
                clearTimeout(fallbackTimer); 
                let transcript = event.results[0][0].transcript.toLowerCase();
                rawTranscriptDisplay.innerText = `[å¬åˆ°å†…å®¹]: "${transcript}"`;
                
                // ã€æ ¸å¿ƒä¿®å¤1ï¼šé­”æ³•è¯†åˆ«çŸ­è¯­ç©ºæ ¼ã€‘
                // æŠŠç”¨æˆ·è¯»å‡ºçš„ "space" å•è¯æš‚æ—¶æ›¿æ¢ä¸ºä¸€ä¸ªç‰¹æ®Šå ä½ç¬¦ '_'
                let processed = transcript.replace(/\bspace\b/g, '_');
                // æ— å·®åˆ«åˆ æ‰å…¶å®ƒæ‰€æœ‰å­—æ¯é—´çš„ç©ºæ ¼ï¼ˆå› ä¸ºç³»ç»Ÿä¼šæŠŠ a p p l e åŠ ä¸Šç©ºæ ¼ï¼‰
                let word = processed.replace(/[^a-z_]/g, '');
                // æœ€åæŠŠå ä½ç¬¦ '_' å˜å›çœŸæ­£çš„ç©ºæ ¼
                word = word.replace(/_/g, ' ').trim();
                
                if (!word) {
                    statusText.innerText = "âš ï¸ è¯†åˆ«ç»“æœä¸­æœªåŒ…å«è‹±æ–‡å­—æ¯ã€‚";
                    return;
                }

                resultWordDisplay.innerText = word;
                statusText.innerText = "æ­£åœ¨ç¿»è¯‘æŸ¥è¯¢ä¸­...";
                await processWord(word); 
            };

            recognition.onerror = (event) => {
                clearTimeout(fallbackTimer);
                const errorMap = {
                    'not-allowed': "å·²æ‹’ç»éº¦å…‹é£æƒé™ã€‚è¯·åœ¨è®¾ç½®ä¸­æ‰“å¼€ã€‚",
                    'no-speech': "æ²¡å¬åˆ°å£°éŸ³ï¼Œè¯·é‡è¯•ã€‚",
                    'network': "ç½‘ç»œå¼‚å¸¸ã€‚"
                };
                statusText.innerText = "âŒ " + (errorMap[event.error] || event.error);
            };

            recognition.onend = () => {
                clearTimeout(fallbackTimer);
                isSystemBusy = false; 
                recordBtn.classList.remove('busy', 'recording');
                recordBtn.innerText = "æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯";
                if(statusText.innerText.includes("ç­‰å¾…ç³»ç»Ÿå›ä¼ ")) {
                    statusText.innerText = "âš ï¸ ç³»ç»Ÿæœªè¿”å›æ•°æ®ï¼Œè¯·é‡è¯»ã€‚";
                }
            };

            try { recognition.start(); } catch (err) { isSystemBusy = false; }
        };

        const stopRecording = (e) => {
            e.preventDefault();
            if (!isSystemBusy) return; 

            if (!hasActuallyStarted) {
                resetRecognition();
                isSystemBusy = false;
                recordBtn.innerText = "æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯";
                statusText.innerText = "æƒé™å·²æ›´æ–°ï¼Œè¯·é‡æ–°æŒ‰ä½æŒ‰é’®å½•éŸ³ã€‚";
                return;
            }

            recordBtn.classList.remove('recording');
            recordBtn.classList.add('busy');
            recordBtn.innerText = "â³ æ¥æ”¶ç»“æœä¸­...";
            statusText.innerText = "å·²æ¾å¼€ï¼Œç­‰å¾…ç³»ç»Ÿå›ä¼ æ•°æ®...";

            fallbackTimer = setTimeout(() => {
                if (isSystemBusy && recognition) {
                    try { recognition.stop(); } catch(err) {}
                }
            }, 2500); 
        };

        recordBtn.addEventListener('mousedown', startRecording);
        recordBtn.addEventListener('touchstart', startRecording, {passive: false});
        recordBtn.addEventListener('mouseup', stopRecording);
        recordBtn.addEventListener('touchend', stopRecording);
        recordBtn.addEventListener('mouseleave', stopRecording);
        recordBtn.addEventListener('touchcancel', stopRecording);

        // ================= 2. æŸ¥è¯ä¸ç¿»è¯‘é€»è¾‘ =================
        async function processWord(word, specificArchive = null) {
            let enMeaning = "æš‚æ— è‹±æ–‡é‡Šä¹‰ï¼ˆçŸ­è¯­æˆ–ä¸“æœ‰åè¯å¯èƒ½æœªè¢«è‹±æ–‡è¯å…¸æ”¶å½•ï¼‰ã€‚";
            let cnMeaning = "æš‚æ— ä¸­æ–‡é‡Šä¹‰ã€‚";
            
            // ä½¿ç”¨ encodeURIComponent ç¡®ä¿çŸ­è¯­ä¸­çš„ç©ºæ ¼èƒ½æ­£ç¡®å‘é€åˆ° API
            const safeWordUrl = encodeURIComponent(word);

            try {
                // 1. è·å–ä¸­æ–‡ç¿»è¯‘ (ä¼˜å…ˆæŸ¥ä¸­æ–‡ï¼ŒçŸ­è¯­æ›´å®¹æ˜“æŸ¥åˆ°)
                const transRes = await fetch(`https://api.mymemory.translated.net/get?q=${safeWordUrl}&langpair=en|zh-CN`);
                const transData = await transRes.json();
                if (transData && transData.responseData) {
                    let text = transData.responseData.translatedText;
                    if (text.toLowerCase() !== word.toLowerCase()) {
                        cnMeaning = text;
                    }
                }
                
                // 2. è·å–è‹±æ–‡æƒå¨é‡Šä¹‰ (å•ç‹¬åŒ…è£¹try-catchï¼Œé˜²æ­¢çŸ­è¯­404æ‰“æ–­æ•´ä¸ªä¿å­˜æµç¨‹)
                try {
                    const dictRes = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${safeWordUrl}`);
                    if (dictRes.ok) {
                        const dictData = await dictRes.json();
                        enMeaning = dictData[0].meanings[0].definitions[0].definition;
                    }
                } catch(e) { /* å¿½ç•¥è‹±æ–‡è¯å…¸çš„æŠ¥é”™ï¼Œä¿ç•™é»˜è®¤æç¤º */ }
                
                statusText.innerText = "âœ… æŸ¥è¯¢æˆåŠŸï¼";
            } catch (error) {
                statusText.innerText = "âš ï¸ ç½‘ç»œå¼‚å¸¸ï¼Œä»…ä¿å­˜æ‹¼å†™";
            }

            const combinedMeaning = `ã€ä¸­ã€‘${cnMeaning}\nã€è‹±ã€‘${enMeaning}`;
            
            meaningDisplay.innerHTML = `<span class="cn-meaning">${cnMeaning}</span><span class="en-meaning">${enMeaning}</span>`;
            resultWordDisplay.innerText = word;

            saveWord(word, combinedMeaning, specificArchive);
            renderVocabList();
        }

        // ================= 3. æ•°æ®ç®¡ç†ä¸æ¸²æŸ“ =================
        function saveWord(word, meaning, specificArchive) {
            const archiveName = specificArchive || (document.getElementById('archiveName').value || today);
            let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if (!vocabData[archiveName]) vocabData[archiveName] = [];
            
            vocabData[archiveName] = vocabData[archiveName].filter(w => w.word !== word);
            vocabData[archiveName].unshift({ word, meaning }); // ç•Œé¢ä¸Šæœ€æ–°çš„æ°¸è¿œåœ¨æœ€å‰é¢
            localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
        }

        // ä¿®æ”¹å•è¯æ‹¼å†™
        function editWord(archive, oldWord) {
            const newWord = prompt(`æ£€æµ‹åˆ°è¯†åˆ«å¯èƒ½é”™è¯¯ã€‚\n\nè¯·å°† "${oldWord}" ä¿®æ”¹ä¸ºæ­£ç¡®çš„æ‹¼å†™ (çŸ­è¯­å¯ä»¥ç›´æ¥åŠ ç©ºæ ¼)ï¼š`, oldWord);
            if (newWord && newWord.trim() !== "" && newWord !== oldWord) {
                // ã€æ ¸å¿ƒä¿®å¤2ï¼šæ‰‹å·¥ç¼–è¾‘ä¿ç•™ç©ºæ ¼ã€‘ æ­£åˆ™è¡¨è¾¾å¼ä¸­åŠ å…¥ \s å…è®¸ç©ºæ ¼ï¼Œå¹¶å°†å¤šä¸ªç©ºæ ¼åˆå¹¶ä¸ºä¸€ä¸ª
                const cleanWord = newWord.replace(/[^a-zA-Z\s]/g, '').replace(/\s+/g, ' ').trim().toLowerCase();
                if(!cleanWord) { alert("å•è¯åªèƒ½åŒ…å«è‹±æ–‡å­—æ¯å’Œç©ºæ ¼ï¼"); return; }
                
                let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
                vocabData[archive] = vocabData[archive].filter(item => item.word !== oldWord);
                if (vocabData[archive].length === 0) delete vocabData[archive];
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
                
                statusText.innerText = `æ­£åœ¨é‡æ–°æŸ¥è¯¢ ${cleanWord} ...`;
                processWord(cleanWord, archive); 
            }
        }

        function deleteWord(archive, word) {
            if(confirm(`ç¡®å®šåˆ é™¤å•è¯ "${word}" å—ï¼Ÿ`)) {
                let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
                vocabData[archive] = vocabData[archive].filter(item => item.word !== word);
                if (vocabData[archive].length === 0) delete vocabData[archive];
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
                renderVocabList();
            }
        }

        function renameArchive(oldName) {
            const newName = prompt("è¯·è¾“å…¥æ–°çš„å½’æ¡£åç§°ï¼š", oldName);
            if (newName && newName.trim() && newName !== oldName) {
                let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
                if (vocabData[newName]) { alert("è¯¥å½’æ¡£åç§°å·²å­˜åœ¨ï¼"); return; }
                vocabData[newName] = vocabData[oldName];
                delete vocabData[oldName];
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
                if(document.getElementById('archiveName').value === oldName) { document.getElementById('archiveName').value = newName; }
                renderVocabList();
            }
        }

        function deleteArchive(name) {
            if (confirm(`âš ï¸ å±é™©æ“ä½œï¼š\nç¡®å®šè¦å½»åº•åˆ é™¤å½’æ¡£ã€${name}ã€‘åŠé‡Œé¢çš„æ‰€æœ‰å•è¯å—ï¼Ÿ\nåˆ é™¤åä¸å¯æ¢å¤ï¼`)) {
                let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
                delete vocabData[name];
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
                renderVocabList();
            }
        }

        // å‘éŸ³åŠŸèƒ½ï¼ˆç°åœ¨ä¼šæ­£ç¡®è¯»å‡ºå¸¦æœ‰ç©ºæ ¼çš„çŸ­è¯­äº†ï¼‰
        function speakWord(word) {
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(word);
            utterance.lang = 'en-US'; 
            utterance.rate = 0.9; 
            window.speechSynthesis.speak(utterance);
        }

        // ================= 4. å¯¼å‡ºé€»è¾‘ =================
        function generateCSV(vocabData, fileName) {
            let csvContent = "\uFEFFå½’æ¡£åç§°,å•è¯,é‡Šä¹‰\n";
            for (const archive in vocabData) {
                // ã€æ ¸å¿ƒä¿®å¤3ï¼šå¯¼å‡ºå€’åºã€‘ä½¿ç”¨ [...Array].reverse() è®©æœ€è€çš„ï¼ˆå…ˆå½•å…¥çš„ï¼‰æ’åœ¨æœ€ä¸Šé¢
                const exportList = [...vocabData[archive]].reverse();
                exportList.forEach(item => {
                    let safeMeaning = item.meaning.replace(/"/g, '""');
                    csvContent += `"${archive}","${item.word}","${safeMeaning}"\n`;
                });
            }
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            link.setAttribute("download", `${fileName}.csv`); // æ–‡ä»¶åå®Œå…¨æŒ‰ä¼ å…¥çš„å€¼ç”Ÿæˆ
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function exportArchive(name) {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if(vocabData[name]) {
                // å•ä¸ªå¯¼å‡ºï¼šæ–‡ä»¶åæ­£å¥½å°±æ˜¯å½’æ¡£åå­—æœ¬èº«
                generateCSV({ [name]: vocabData[name] }, name);
            }
        }

        exportBtn.addEventListener('click', () => {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if (Object.keys(vocabData).length === 0) { alert("ç”Ÿè¯æœ¬æ˜¯ç©ºçš„ï¼"); return; }
            
            // å…¨éƒ¨å¯¼å‡ºï¼šç”Ÿæˆçº¯æ•°å­—æ—¶é—´æˆ³ 20260225095130
            const now = new Date();
            const timeStr = now.getFullYear().toString() + 
                            (now.getMonth() + 1).toString().padStart(2, '0') + 
                            now.getDate().toString().padStart(2, '0') + 
                            now.getHours().toString().padStart(2, '0') + 
                            now.getMinutes().toString().padStart(2, '0') + 
                            now.getSeconds().toString().padStart(2, '0');
            
            generateCSV(vocabData, timeStr);
        });

        function renderVocabList() {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            vocabListDisplay.innerHTML = '';
            
            const sortedArchives = Object.keys(vocabData).sort((a, b) => b.localeCompare(a));

            sortedArchives.forEach(archive => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'archive-group';
                
                const header = document.createElement('div');
                header.className = 'archive-header';
                header.innerHTML = `
                    <div class="archive-title">
                        ğŸ“‚ ${archive} <span style="font-size:12px;color:#888;">(${vocabData[archive].length}è¯)</span>
                    </div>
                    <div class="archive-actions">
                        <button class="icon-btn" onclick="exportArchive('${archive}')">ğŸ’¾</button>
                        <button class="icon-btn" onclick="renameArchive('${archive}')">âœï¸</button>
                        <button class="icon-btn danger" onclick="deleteArchive('${archive}')">ğŸ—‘ï¸</button>
                    </div>
                `;
                groupDiv.appendChild(header);
                
                vocabData[archive].forEach(item => {
                    const meaningParts = item.meaning.split('\nã€è‹±ã€‘');
                    let cnText = meaningParts[0].replace('ã€ä¸­ã€‘', '');
                    let enText = meaningParts[1] || '';

                    const wordDiv = document.createElement('div');
                    wordDiv.className = 'word-item';
                    
                    wordDiv.innerHTML = `
                        <div class="word-content">
                            <div class="word-header">
                                <span class="word-word">${item.word}</span>
                                <button class="audio-btn" onclick="speakWord('${item.word.replace(/'/g, "\\'")}')">ğŸ”Š</button>
                            </div>
                            <div class="word-meaning">
                                <div class="word-meaning-cn">${cnText}</div>
                                <div style="color:#888; font-size:13px;">${enText}</div>
                            </div>
                        </div>
                        <div class="action-btns">
                            <button class="icon-btn" onclick="editWord('${archive}', '${item.word.replace(/'/g, "\\'")}')">âœï¸</button>
                            <button class="icon-btn danger" onclick="deleteWord('${archive}', '${item.word.replace(/'/g, "\\'")}')">ğŸ—‘ï¸</button>
                        </div>
                    `;
                    groupDiv.appendChild(wordDiv);
                });
                vocabListDisplay.appendChild(groupDiv);
            });
        }

        renderVocabList();
    </script>
</body>
</html>
