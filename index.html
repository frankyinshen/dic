<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¯­éŸ³æ‹¼å†™ç”Ÿè¯æœ¬ v2.2.0</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; max-width: 500px; margin: 0 auto; padding: 20px; background: #f4f7f6; color: #333; }
        .card { background: white; padding: 25px 20px; border-radius: 16px; box-shadow: 0 8px 20px rgba(0,0,0,0.06); margin-bottom: 20px; text-align: center; }
        h2 { margin-top: 0; font-size: 20px; color: #1c1c1e; display: flex; justify-content: space-between; align-items: center;}
        .version-tag { font-size: 12px; background: #34c759; padding: 2px 8px; border-radius: 10px; color: white; font-weight: bold; }
        
        #recordBtn { background: #007aff; color: white; border: none; padding: 16px 30px; font-size: 18px; font-weight: 600; border-radius: 50px; cursor: pointer; user-select: none; transition: all 0.2s; width: 100%; box-shadow: 0 4px 12px rgba(0,122,255,0.3); -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent;}
        
        /* æŒ‰ä¸‹æ—¶çš„çŠ¶æ€ */
        #recordBtn.recording { background: #ff3b30; box-shadow: 0 4px 12px rgba(255,59,48,0.4); transform: scale(0.96); }
        /* é”å®šå¤„ç†æ—¶çš„çŠ¶æ€ */
        #recordBtn.busy { background: #8e8e93; box-shadow: none; transform: none; pointer-events: none; }

        #exportBtn { background: #34c759; color: white; border: none; padding: 8px 15px; font-size: 14px; font-weight: 600; border-radius: 8px; cursor: pointer; transition: opacity 0.2s; }
        #exportBtn:active { opacity: 0.7; }

        .status { margin-top: 15px; font-size: 14px; color: #8e8e93; min-height: 20px; font-weight: 500; }
        #rawTranscript { margin-top: 8px; font-size: 13px; color: #d09a00; display: block; min-height: 15px; }
        #resultWord { font-size: 40px; font-weight: 800; margin: 15px 0; color: #1c1c1e; letter-spacing: 2px; }
        #meaning { font-size: 15px; color: #3a3a3c; min-height: 45px; background: #f2f2f7; padding: 12px; border-radius: 12px; line-height: 1.5;}
        
        .input-group { text-align: left; margin-bottom: 20px; }
        label { font-size: 14px; font-weight: 600; color: #636366; display: block; margin-bottom: 8px; }
        input[type="text"] { width: 100%; padding: 12px; border: 1px solid #d1d1d6; border-radius: 10px; box-sizing: border-box; font-size: 16px; outline: none; }
        
        .word-list { text-align: left; }
        .archive-group { margin-top: 20px; }
        .archive-header { background: #f2f2f7; padding: 10px 15px; border-radius: 10px; font-weight: 700; font-size: 15px; color: #1c1c1e; display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;}
        .word-item { padding: 12px 10px; border-bottom: 1px solid #e5e5ea; display: flex; flex-direction: column;}
        .word-item:last-child { border-bottom: none; }
        .word-word { font-size: 18px; font-weight: 700; color: #007aff; }
        .word-meaning { font-size: 14px; color: #636366; margin-top: 6px; }
    </style>
</head>
<body>

    <div class="card">
        <h2>
            ğŸ™ï¸ æŒ‰ä½è¯»å­—æ¯æ‹¼å†™
            <span class="version-tag">v2.2.0-Stable</span>
        </h2>
        
        <div class="input-group">
            <label for="archiveName">å½’æ¡£åç§° (å¯ä¿®æ”¹ä¸ºä¹¦å/ç« èŠ‚):</label>
            <input type="text" id="archiveName" placeholder="ä¾‹å¦‚: 2026-02-20 æˆ– ç®€çˆ±-ç¬¬ä¸€ç« ">
        </div>

        <button id="recordBtn">æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯</button>
        <div class="status" id="statusText">å‡†å¤‡å°±ç»ª...</div>
        <div id="rawTranscript"></div>
        
        <div id="resultWord">...</div>
        <div id="meaning">ç­‰å¾…æŸ¥è¯...</div>
    </div>

    <div class="card word-list">
        <h2>
            ğŸ“š ä½ çš„ç”Ÿè¯æœ¬
            <button id="exportBtn">ğŸ’¾ å¯¼å‡º CSV</button>
        </h2>
        <div id="vocabList"></div>
    </div>

    <script>
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('archiveName').value = today;

        const recordBtn = document.getElementById('recordBtn');
        const exportBtn = document.getElementById('exportBtn');
        const statusText = document.getElementById('statusText');
        const rawTranscriptDisplay = document.getElementById('rawTranscript');
        const resultWordDisplay = document.getElementById('resultWord');
        const meaningDisplay = document.getElementById('meaning');
        const vocabListDisplay = document.getElementById('vocabList');

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;
        
        // æ ¸å¿ƒé”æœºåˆ¶
        let isSystemBusy = false; // ç³»ç»Ÿæ˜¯å¦æ­£åœ¨å½•éŸ³æˆ–å¤„ç†ä¸­
        let isUserPressing = false; // ç”¨æˆ·æ‰‹æŒ‡æ˜¯å¦æ­£æŒ‰åœ¨æŒ‰é’®ä¸Š

        // 1. æŒ‰ä¸‹æŒ‰é’®ï¼šå¼€å§‹å½•éŸ³
        const startRecording = (e) => {
            e.preventDefault();
            
            // å¦‚æœä¸Šä¸€ä¸ªè¯è¿˜åœ¨å¤„ç†ï¼ˆéº¦å…‹é£é€šé“æœªå…³é—­ï¼‰ï¼Œç›´æ¥æ‹¦æˆªæ“ä½œï¼Œé˜²æ­¢å¡æ­»
            if (isSystemBusy) return; 
            
            isSystemBusy = true;
            isUserPressing = true;
            rawTranscriptDisplay.innerText = "";

            if (!SpeechRecognition) {
                statusText.innerText = "âŒ æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«ã€‚";
                isSystemBusy = false;
                return;
            }

            // æ¯æ¬¡æŒ‰ä¸‹ï¼Œå¿…å®šåˆ›å»ºä¸€ä¸ªå´­æ–°çš„å®ä¾‹
            recognition = new SpeechRecognition();
            recognition.lang = 'en-US'; 
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;
            recognition.continuous = false;

            recognition.onstart = () => {
                recordBtn.classList.add('recording');
                recordBtn.innerText = "ğŸ›‘ æ­£åœ¨è†å¬... (æ¾å¼€ç»“æŸ)";
                statusText.innerText = "è¯·è¯»å‡ºå­—æ¯ (ä¾‹å¦‚è¯» 'A P P L E')...";
            };

            recognition.onresult = async (event) => {
                const transcript = event.results[0][0].transcript;
                rawTranscriptDisplay.innerText = `[åº•å±‚å¬åˆ°]: "${transcript}"`;
                
                const word = transcript.replace(/[^a-zA-Z]/g, '').toLowerCase();
                
                if (!word) {
                    statusText.innerText = "âš ï¸ æœªè¯†åˆ«å‡ºå­—æ¯ï¼Œè¯·å‘éŸ³æ›´æ¸…æ™°äº›ã€‚";
                    return;
                }

                resultWordDisplay.innerText = word;
                statusText.innerText = "æ­£åœ¨æŸ¥è¯¢å­—å…¸...";
                await processWord(word);
            };

            recognition.onerror = (event) => {
                console.error("è¯†åˆ«é”™è¯¯:", event.error);
                const errorMap = {
                    'network': "ç½‘ç»œä¸ä½³ï¼Œæ— æ³•è¿æ¥è‹¹æœæœåŠ¡å™¨ã€‚",
                    'not-allowed': "è¯·åœ¨ Safari è®¾ç½®ä¸­å…è®¸éº¦å…‹é£æƒé™ã€‚",
                    'no-speech': "æ²¡å¬åˆ°å£°éŸ³ï¼Œè¯·é è¿›éº¦å…‹é£ã€‚",
                    'service-not-allowed': "è¯·åœ¨ã€è®¾ç½®-é€šç”¨-é”®ç›˜-å¯ç”¨å¬å†™ã€‘ä¸­å¼€å¯ã€‚",
                    'aborted': "è¯†åˆ«å·²å–æ¶ˆã€‚"
                };
                statusText.innerText = "âŒ " + (errorMap[event.error] || event.error);
            };

            // onend ä»£è¡¨éº¦å…‹é£é€šé“å·²ç»å½»åº•å…³é—­
            recognition.onend = () => {
                isSystemBusy = false; // å½»åº•é‡Šæ”¾ç³»ç»Ÿé”
                
                // æ¢å¤æŒ‰é’®åˆå§‹çŠ¶æ€
                recordBtn.classList.remove('busy');
                recordBtn.classList.remove('recording');
                recordBtn.innerText = "æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯";

                // å¦‚æœæ¾æ‰‹åç³»ç»Ÿä¸¢å¼ƒäº†éŸ³é¢‘ï¼ˆæ²¡è§¦å‘ onresultï¼‰ï¼Œè¿›è¡Œè¡¥æ•‘æç¤º
                if(statusText.innerText === "å·²æ¾å¼€ï¼Œç­‰å¾…ç³»ç»Ÿè§£æ...") {
                    statusText.innerText = "æœªæ•æ‰åˆ°æœ‰æ•ˆå£°éŸ³ï¼Œè¯·é‡è¯•ã€‚";
                }
            };

            try {
                recognition.start();
            } catch (err) {
                isSystemBusy = false;
                statusText.innerText = "å¯åŠ¨éº¦å…‹é£å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚";
            }
        };

        // 2. æ¾å¼€æŒ‰é’®ï¼šç»“æŸå¹¶ç­‰å¾…ç»“æœ
        const stopRecording = (e) => {
            e.preventDefault();
            if (!isUserPressing) return; // é˜²æ­¢å¤šé‡äº‹ä»¶é‡å¤è§¦å‘
            isUserPressing = false;

            if (recognition && isSystemBusy) {
                recognition.stop();
                
                // æ¾å¼€æ‰‹åï¼Œåœ¨ onend è§¦å‘å‰ï¼ŒæŒ‰é’®å˜æˆç°è‰²é”å®šçŠ¶æ€
                recordBtn.classList.remove('recording');
                recordBtn.classList.add('busy');
                recordBtn.innerText = "â³ å¤„ç†ä¸­...";
                statusText.innerText = "å·²æ¾å¼€ï¼Œç­‰å¾…ç³»ç»Ÿè§£æ...";
            }
        };

        // ç»‘å®šäº‹ä»¶ï¼ˆå…¼å®¹è§¦æ‘¸å±å’Œé¼ æ ‡ï¼‰
        recordBtn.addEventListener('mousedown', startRecording);
        recordBtn.addEventListener('touchstart', startRecording, {passive: false});
        
        // æ¾å¼€ã€ç§»å‡ºæŒ‰é’®ã€ç³»ç»Ÿæ‰“æ–­ï¼Œéƒ½è§¦å‘ç»“æŸ
        recordBtn.addEventListener('mouseup', stopRecording);
        recordBtn.addEventListener('touchend', stopRecording);
        recordBtn.addEventListener('mouseleave', stopRecording);
        recordBtn.addEventListener('touchcancel', stopRecording);

        // å¤„ç†å•è¯å’Œç¼“å­˜é€»è¾‘ï¼ˆä¿æŒä¸å˜ï¼‰
        async function processWord(word) {
            let meaning = "æš‚æ— é‡Šä¹‰ã€‚";
            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (response.ok) {
                    const data = await response.json();
                    meaning = data[0].meanings[0].definitions[0].definition;
                    statusText.innerText = "âœ… æŸ¥è¯¢æˆåŠŸï¼";
                } else {
                    statusText.innerText = "âš ï¸ å­—å…¸ä¸­æœªæ‰¾åˆ°è¯¥è¯ã€‚";
                }
            } catch (error) {
                meaning = "ç½‘ç»œé”™è¯¯ï¼ŒæŸ¥è¯å¤±è´¥ã€‚";
                statusText.innerText = "âŒ æŸ¥è¯è¯·æ±‚å¤±è´¥";
            }

            meaningDisplay.innerText = meaning;
            saveWord(word, meaning);
            renderVocabList();
        }

        function saveWord(word, meaning) {
            const archiveName = document.getElementById('archiveName').value || today;
            let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if (!vocabData[archiveName]) vocabData[archiveName] = [];
            const exists = vocabData[archiveName].find(w => w.word === word);
            if (!exists) {
                vocabData[archiveName].unshift({ word, meaning });
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
            }
        }

        function renderVocabList() {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            vocabListDisplay.innerHTML = '';
            for (const archive in vocabData) {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'archive-group';
                const header = document.createElement('div');
                header.className = 'archive-header';
                header.innerHTML = `<span>ğŸ“‚ ${archive}</span> <span style="font-size: 13px; color: #8e8e93; font-weight: normal;">${vocabData[archive].length} è¯</span>`;
                groupDiv.appendChild(header);
                vocabData[archive].forEach(item => {
                    const wordDiv = document.createElement('div');
                    wordDiv.className = 'word-item';
                    wordDiv.innerHTML = `<span class="word-word">${item.word}</span><span class="word-meaning">${item.meaning}</span>`;
                    groupDiv.appendChild(wordDiv);
                });
                vocabListDisplay.appendChild(groupDiv);
            }
        }

        exportBtn.addEventListener('click', () => {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if (Object.keys(vocabData).length === 0) {
                alert("ç”Ÿè¯æœ¬æ˜¯ç©ºçš„ï¼"); return;
            }
            let csvContent = "\uFEFFå½’æ¡£åç§°,å•è¯,é‡Šä¹‰\n";
            for (const archive in vocabData) {
                vocabData[archive].forEach(item => {
                    let safeMeaning = item.meaning.replace(/"/g, '""');
                    csvContent += `"${archive}","${item.word}","${safeMeaning}"\n`;
                });
            }
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            link.setAttribute("download", `ç”Ÿè¯æœ¬_${today}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        renderVocabList();
    </script>
</body>
</html>
