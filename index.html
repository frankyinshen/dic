<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¯­éŸ³æ‹¼å†™ç”Ÿè¯æœ¬ v3.0.0</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; max-width: 500px; margin: 0 auto; padding: 20px; background: #f4f7f6; color: #333; }
        .card { background: white; padding: 25px 20px; border-radius: 16px; box-shadow: 0 8px 20px rgba(0,0,0,0.06); margin-bottom: 20px; text-align: center; }
        h2 { margin-top: 0; font-size: 20px; color: #1c1c1e; display: flex; justify-content: space-between; align-items: center;}
        .version-tag { font-size: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 3px 10px; border-radius: 12px; color: #fff; font-weight: bold; letter-spacing: 0.5px;}
        
        #recordBtn { background: #007aff; color: white; border: none; padding: 18px 30px; font-size: 18px; font-weight: 600; border-radius: 50px; cursor: pointer; user-select: none; transition: all 0.2s; width: 100%; box-shadow: 0 4px 12px rgba(0,122,255,0.3); -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent;}
        #recordBtn.recording { background: #ff3b30; box-shadow: 0 4px 12px rgba(255,59,48,0.4); transform: scale(0.96); }
        #recordBtn.busy { background: #ff9500; box-shadow: 0 4px 12px rgba(255,149,0,0.4); pointer-events: none; transform: none; }

        .btn-export-all { background: #34c759; color: white; border: none; padding: 8px 15px; font-size: 14px; font-weight: 600; border-radius: 8px; cursor: pointer; }
        
        .status { margin-top: 15px; font-size: 14px; color: #8e8e93; min-height: 20px; font-weight: 500; }
        #rawTranscript { margin-top: 8px; font-size: 13px; color: #ff9500; display: block; min-height: 15px; font-weight: bold;}
        #resultWord { font-size: 40px; font-weight: 800; margin: 15px 0; color: #1c1c1e; letter-spacing: 2px; }
        #meaning { font-size: 15px; color: #3a3a3c; min-height: 45px; background: #f2f2f7; padding: 12px; border-radius: 12px; line-height: 1.5; text-align: left;}
        .cn-meaning { color: #d9534f; font-weight: bold; margin-bottom: 5px; display: block; }
        
        .input-group { text-align: left; margin-bottom: 20px; }
        label { font-size: 14px; font-weight: 600; color: #636366; display: block; margin-bottom: 8px; }
        input[type="text"] { width: 100%; padding: 12px; border: 1px solid #d1d1d6; border-radius: 10px; box-sizing: border-box; font-size: 16px; outline: none; }
        
        .word-list { text-align: left; }
        .archive-group { margin-top: 25px; border: 1px solid #e5e5ea; border-radius: 12px; overflow: hidden; }
        .archive-header { background: #f8f8f8; padding: 12px 15px; font-weight: 700; font-size: 15px; color: #1c1c1e; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #e5e5ea;}
        .archive-title { flex: 1; display: flex; align-items: center; gap: 5px; }
        .archive-actions { display: flex; gap: 8px; }
        
        .word-item { padding: 15px; border-bottom: 1px solid #f2f2f7; display: flex; justify-content: space-between; align-items: flex-start;}
        .word-item:last-child { border-bottom: none; }
        .word-content { display: flex; flex-direction: column; flex: 1; margin-right: 10px; }
        .word-header { display: flex; align-items: center; gap: 8px; }
        .word-word { font-size: 18px; font-weight: 700; color: #007aff; }
        
        /* æœ—è¯»æŒ‰é’® */
        .audio-btn { background: #e5f1ff; color: #007aff; border: none; border-radius: 50%; width: 26px; height: 26px; display: flex; align-items: center; justify-content: center; font-size: 12px; cursor: pointer; }
        .audio-btn:active { transform: scale(0.9); }
        
        .word-meaning { font-size: 14px; color: #636366; margin-top: 6px; line-height: 1.5; }
        .word-meaning-cn { color: #d9534f; font-weight: 600; margin-bottom: 3px; }
        
        /* æ“ä½œæŒ‰é’®ç»„ */
        .action-btns { display: flex; gap: 5px; }
        .icon-btn { background: #f2f2f7; border: none; font-size: 14px; cursor: pointer; padding: 6px 10px; border-radius: 8px; transition: background 0.2s; -webkit-tap-highlight-color: transparent; }
        .icon-btn:active { background: #e5e5ea; }
        .icon-btn.danger:active { background: #ffe5e5; color: red;}
    </style>
</head>
<body>

    <div class="card">
        <h2>
            ğŸ™ï¸ è¯­éŸ³æ‹¼å†™ç”Ÿè¯æœ¬
            <span class="version-tag">v3.0.0-Ultimate</span>
        </h2>
        
        <div class="input-group">
            <label for="archiveName">å½’æ¡£åç§° (å¯ä¿®æ”¹ä¸ºä¹¦å/ç« èŠ‚):</label>
            <input type="text" id="archiveName" placeholder="ä¾‹å¦‚: 2026-02-20">
        </div>

        <button id="recordBtn">æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯</button>
        <div class="status" id="statusText">å‡†å¤‡å°±ç»ª...</div>
        <div id="rawTranscript"></div>
        
        <div id="resultWord">...</div>
        <div id="meaning">ç­‰å¾…æŸ¥è¯...</div>
    </div>

    <div class="card word-list">
        <h2>
            ğŸ“š ä½ çš„ç”Ÿè¯æœ¬
            <button id="exportBtn" class="btn-export-all">ğŸ’¾ å¯¼å‡ºå…¨éƒ¨</button>
        </h2>
        <div id="vocabList"></div>
    </div>

    <script>
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('archiveName').value = today;

        const recordBtn = document.getElementById('recordBtn');
        const exportBtn = document.getElementById('exportBtn');
        const statusText = document.getElementById('statusText');
        const rawTranscriptDisplay = document.getElementById('rawTranscript');
        const resultWordDisplay = document.getElementById('resultWord');
        const meaningDisplay = document.getElementById('meaning');
        const vocabListDisplay = document.getElementById('vocabList');

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;
        
        let isSystemBusy = false; 
        let fallbackTimer = null; 
        let hasActuallyStarted = false; // æ–°å¢ï¼šè§£å†³æƒé™ç”³è¯·å¼¹çª—æ—¶çš„å¡æ­»Bug

        function resetRecognition() {
            if (recognition) {
                recognition.onstart = null;
                recognition.onresult = null;
                recognition.onerror = null;
                recognition.onend = null;
                try { recognition.abort(); } catch(e){}
                recognition = null;
            }
            clearTimeout(fallbackTimer);
        }

        // ================= 1. è¯­éŸ³è¯†åˆ«æ ¸å¿ƒé€»è¾‘ =================
        const startRecording = (e) => {
            e.preventDefault();
            if (isSystemBusy) return; 
            
            isSystemBusy = true;
            hasActuallyStarted = false; 
            rawTranscriptDisplay.innerText = "";
            resetRecognition();

            if (!SpeechRecognition) {
                statusText.innerText = "âŒ æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«ã€‚";
                isSystemBusy = false;
                return;
            }

            recognition = new SpeechRecognition();
            recognition.lang = 'en-US'; 
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;
            recognition.continuous = false;

            recognition.onstart = () => {
                hasActuallyStarted = true; // çœŸæ­£å¼€å§‹å½•éŸ³äº†
                recordBtn.classList.add('recording');
                recordBtn.innerText = "ğŸ›‘ æ­£åœ¨è†å¬... (è¯·è¯´å®Œå†æ¾æ‰‹)";
                statusText.innerText = "è¯·å¼€å§‹æ‹¼è¯»å­—æ¯...";
            };

            recognition.onresult = async (event) => {
                clearTimeout(fallbackTimer); 
                const transcript = event.results[0][0].transcript;
                rawTranscriptDisplay.innerText = `[å¬åˆ°å†…å®¹]: "${transcript}"`;
                
                const word = transcript.replace(/[^a-zA-Z]/g, '').toLowerCase();
                if (!word) {
                    statusText.innerText = "âš ï¸ è¯†åˆ«ç»“æœä¸­æœªåŒ…å«è‹±æ–‡å­—æ¯ã€‚";
                    return;
                }

                resultWordDisplay.innerText = word;
                statusText.innerText = "æ­£åœ¨ç¿»è¯‘æŸ¥è¯¢ä¸­...";
                await processWord(word); // é»˜è®¤ä¿å­˜åˆ°å½“å‰è¾“å…¥æ¡†çš„å½’æ¡£
            };

            recognition.onerror = (event) => {
                clearTimeout(fallbackTimer);
                const errorMap = {
                    'not-allowed': "å·²æ‹’ç»éº¦å…‹é£æƒé™ã€‚è¯·åœ¨è®¾ç½®ä¸­æ‰“å¼€ã€‚",
                    'no-speech': "æ²¡å¬åˆ°å£°éŸ³ï¼Œè¯·é‡è¯•ã€‚",
                    'network': "ç½‘ç»œå¼‚å¸¸ã€‚"
                };
                statusText.innerText = "âŒ " + (errorMap[event.error] || event.error);
            };

            recognition.onend = () => {
                clearTimeout(fallbackTimer);
                isSystemBusy = false; 
                recordBtn.classList.remove('busy', 'recording');
                recordBtn.innerText = "æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯";
                if(statusText.innerText.includes("ç­‰å¾…ç³»ç»Ÿå›ä¼ ")) {
                    statusText.innerText = "âš ï¸ ç³»ç»Ÿæœªè¿”å›æ•°æ®ï¼Œè¯·é‡è¯»ã€‚";
                }
            };

            try { recognition.start(); } catch (err) { isSystemBusy = false; }
        };

        const stopRecording = (e) => {
            e.preventDefault();
            if (!isSystemBusy) return; 

            // ã€æ ¸å¿ƒä¿®å¤ã€‘ï¼šå¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æˆæƒéº¦å…‹é£å¼¹çª—å¯¼è‡´æ¾æ‰‹ï¼Œæ­¤æ—¶æ ¹æœ¬æ²¡å¼€å§‹å½•éŸ³
            if (!hasActuallyStarted) {
                resetRecognition();
                isSystemBusy = false;
                recordBtn.innerText = "æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯";
                statusText.innerText = "æƒé™å·²æ›´æ–°ï¼Œè¯·é‡æ–°æŒ‰ä½æŒ‰é’®å½•éŸ³ã€‚";
                return;
            }

            // æ­£å¸¸æ¾æ‰‹ï¼Œè¿›å…¥ç¼“å†²æœŸ
            recordBtn.classList.remove('recording');
            recordBtn.classList.add('busy');
            recordBtn.innerText = "â³ æ¥æ”¶ç»“æœä¸­...";
            statusText.innerText = "å·²æ¾å¼€ï¼Œç­‰å¾…ç³»ç»Ÿå›ä¼ æ•°æ®...";

            fallbackTimer = setTimeout(() => {
                if (isSystemBusy && recognition) {
                    try { recognition.stop(); } catch(err) {}
                }
            }, 2500); 
        };

        recordBtn.addEventListener('mousedown', startRecording);
        recordBtn.addEventListener('touchstart', startRecording, {passive: false});
        recordBtn.addEventListener('mouseup', stopRecording);
        recordBtn.addEventListener('touchend', stopRecording);
        recordBtn.addEventListener('mouseleave', stopRecording);
        recordBtn.addEventListener('touchcancel', stopRecording);


        // ================= 2. æŸ¥è¯ä¸ç¿»è¯‘é€»è¾‘ =================
        async function processWord(word, specificArchive = null) {
            let enMeaning = "æš‚æ— è‹±æ–‡é‡Šä¹‰ã€‚";
            let cnMeaning = "æš‚æ— ä¸­æ–‡é‡Šä¹‰ã€‚";

            try {
                // 1. è·å–ä¸­æ–‡ç¿»è¯‘ (ä½¿ç”¨å…è´¹çš„ MyMemory API)
                const transRes = await fetch(`https://api.mymemory.translated.net/get?q=${word}&langpair=en|zh-CN`);
                const transData = await transRes.json();
                if (transData && transData.responseData) {
                    let text = transData.responseData.translatedText;
                    // é˜²æ­¢æœºå™¨ç¿»è¯‘åŸæ ·è¿”å›è‹±æ–‡
                    if (text.toLowerCase() !== word.toLowerCase()) {
                        cnMeaning = text;
                    }
                }
                
                // 2. è·å–è‹±æ–‡æƒå¨é‡Šä¹‰
                const dictRes = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (dictRes.ok) {
                    const dictData = await dictRes.json();
                    enMeaning = dictData[0].meanings[0].definitions[0].definition;
                }
                statusText.innerText = "âœ… æŸ¥è¯¢æˆåŠŸï¼";
            } catch (error) {
                statusText.innerText = "âš ï¸ ç½‘ç»œå¼‚å¸¸ï¼Œä»…ä¿å­˜æ‹¼å†™";
            }

            const combinedMeaning = `ã€ä¸­ã€‘${cnMeaning}\nã€è‹±ã€‘${enMeaning}`;
            
            // é¡¶éƒ¨æ˜¾ç¤ºåŒºåŸŸæ›´æ–°
            meaningDisplay.innerHTML = `<span class="cn-meaning">${cnMeaning}</span><span class="en-meaning">${enMeaning}</span>`;
            resultWordDisplay.innerText = word;

            // å­˜å…¥å½’æ¡£
            saveWord(word, combinedMeaning, specificArchive);
            renderVocabList();
        }

        // ================= 3. æ•°æ®ç®¡ç†ä¸æ¸²æŸ“ =================
        function saveWord(word, meaning, specificArchive) {
            const archiveName = specificArchive || (document.getElementById('archiveName').value || today);
            let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if (!vocabData[archiveName]) vocabData[archiveName] = [];
            
            // å¦‚æœå­˜åœ¨æ—§çš„åŒåå•è¯ï¼Œå…ˆåˆ é™¤ï¼Œä¿è¯æ–°æŸ¥çš„è¯æ€»æ˜¯æ”¾åœ¨æœ€é¡¶ç«¯ï¼ˆæœ€æ–°ï¼‰
            vocabData[archiveName] = vocabData[archiveName].filter(w => w.word !== word);
            
            // unshift ä¿è¯æœ€æ–°çš„å•è¯æ°¸è¿œåœ¨æ•°ç»„ç´¢å¼• 0 çš„ä½ç½®
            vocabData[archiveName].unshift({ word, meaning });
            localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
        }

        // ä¿®æ”¹å•è¯æ‹¼å†™ (æ ¸å¿ƒéœ€æ±‚)
        function editWord(archive, oldWord) {
            const newWord = prompt(`æ£€æµ‹åˆ°è¯†åˆ«å¯èƒ½é”™è¯¯ã€‚\n\nè¯·å°† "${oldWord}" ä¿®æ”¹ä¸ºæ­£ç¡®çš„æ‹¼å†™ï¼š`, oldWord);
            if (newWord && newWord.trim() !== "" && newWord !== oldWord) {
                const cleanWord = newWord.replace(/[^a-zA-Z]/g, '').toLowerCase();
                if(!cleanWord) { alert("å•è¯åªèƒ½åŒ…å«è‹±æ–‡å­—æ¯ï¼"); return; }
                
                // 1. å…ˆä»åˆ—è¡¨ä¸­åˆ æ‰é‚£ä¸ªè®¤é”™çš„è¯
                let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
                vocabData[archive] = vocabData[archive].filter(item => item.word !== oldWord);
                if (vocabData[archive].length === 0) delete vocabData[archive];
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
                
                // 2. å¸¦ç€ç‰¹å®šçš„å½’æ¡£åç§°å»æŸ¥æ–°è¯å¹¶è‡ªåŠ¨ä¿å­˜è¿›å»
                statusText.innerText = `æ­£åœ¨é‡æ–°æŸ¥è¯¢ ${cleanWord} ...`;
                processWord(cleanWord, archive); 
            }
        }

        function deleteWord(archive, word) {
            if(confirm(`ç¡®å®šåˆ é™¤å•è¯ "${word}" å—ï¼Ÿ`)) {
                let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
                vocabData[archive] = vocabData[archive].filter(item => item.word !== word);
                if (vocabData[archive].length === 0) delete vocabData[archive];
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
                renderVocabList();
            }
        }

        // å½’æ¡£ç®¡ç†
        function renameArchive(oldName) {
            const newName = prompt("è¯·è¾“å…¥æ–°çš„å½’æ¡£åç§°ï¼š", oldName);
            if (newName && newName.trim() && newName !== oldName) {
                let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
                if (vocabData[newName]) {
                    alert("è¯¥å½’æ¡£åç§°å·²å­˜åœ¨ï¼"); return;
                }
                vocabData[newName] = vocabData[oldName];
                delete vocabData[oldName];
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
                if(document.getElementById('archiveName').value === oldName) {
                    document.getElementById('archiveName').value = newName;
                }
                renderVocabList();
            }
        }

        function deleteArchive(name) {
            if (confirm(`âš ï¸ å±é™©æ“ä½œï¼š\nç¡®å®šè¦å½»åº•åˆ é™¤å½’æ¡£ã€${name}ã€‘åŠé‡Œé¢çš„æ‰€æœ‰å•è¯å—ï¼Ÿ\nåˆ é™¤åä¸å¯æ¢å¤ï¼`)) {
                let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
                delete vocabData[name];
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
                renderVocabList();
            }
        }

        // iOS åŸç”Ÿå‘éŸ³åŠŸèƒ½
        function speakWord(word) {
            const utterance = new SpeechSynthesisUtterance(word);
            utterance.lang = 'en-US'; 
            utterance.rate = 0.9; // ç¨å¾®æ”¾æ…¢è¯­é€Ÿæ–¹ä¾¿å­¦ä¹ 
            window.speechSynthesis.speak(utterance);
        }

        // å¯¼å‡ºåŠŸèƒ½
        function generateCSV(vocabData, fileNamePrefix) {
            let csvContent = "\uFEFFå½’æ¡£åç§°,å•è¯,é‡Šä¹‰\n";
            for (const archive in vocabData) {
                vocabData[archive].forEach(item => {
                    let safeMeaning = item.meaning.replace(/"/g, '""');
                    csvContent += `"${archive}","${item.word}","${safeMeaning}"\n`;
                });
            }
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            link.setAttribute("download", `${fileNamePrefix}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function exportArchive(name) {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if(vocabData[name]) {
                generateCSV({ [name]: vocabData[name] }, `ç”Ÿè¯å½’æ¡£_${name}`);
            }
        }

        exportBtn.addEventListener('click', () => {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if (Object.keys(vocabData).length === 0) { alert("ç”Ÿè¯æœ¬æ˜¯ç©ºçš„ï¼"); return; }
            generateCSV(vocabData, `å…¨éƒ¨ç”Ÿè¯æœ¬_${today}`);
        });

        // æ¸²æŸ“åˆ—è¡¨
        function renderVocabList() {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            vocabListDisplay.innerHTML = '';
            
            // å°†å½’æ¡£æŒ‰åç§°å€’åºæ’åˆ—ï¼ˆæœ€æ–°çš„æ—¥æœŸ/åå­—æ’åœ¨æœ€å‰é¢ï¼‰
            const sortedArchives = Object.keys(vocabData).sort((a, b) => b.localeCompare(a));

            sortedArchives.forEach(archive => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'archive-group';
                
                // å½’æ¡£å¤´éƒ¨æ  (å¢åŠ æ”¹åã€åˆ é™¤ã€å¯¼å‡ºåŠŸèƒ½)
                const header = document.createElement('div');
                header.className = 'archive-header';
                header.innerHTML = `
                    <div class="archive-title">
                        ğŸ“‚ ${archive} <span style="font-size:12px;color:#888;">(${vocabData[archive].length}è¯)</span>
                    </div>
                    <div class="archive-actions">
                        <button class="icon-btn" onclick="exportArchive('${archive}')">ğŸ’¾</button>
                        <button class="icon-btn" onclick="renameArchive('${archive}')">âœï¸</button>
                        <button class="icon-btn danger" onclick="deleteArchive('${archive}')">ğŸ—‘ï¸</button>
                    </div>
                `;
                groupDiv.appendChild(header);
                
                // ç”±äºå­˜å…¥æ—¶ç”¨äº† unshiftï¼Œéå†æ—¶æœ¬èº«å°±æ˜¯æœ€æ–°çš„åœ¨æœ€å‰é¢
                vocabData[archive].forEach(item => {
                    // åˆ†ç¦»ä¸­è‹±æ–‡é‡Šä¹‰
                    const meaningParts = item.meaning.split('\nã€è‹±ã€‘');
                    let cnText = meaningParts[0].replace('ã€ä¸­ã€‘', '');
                    let enText = meaningParts[1] || '';

                    const wordDiv = document.createElement('div');
                    wordDiv.className = 'word-item';
                    
                    wordDiv.innerHTML = `
                        <div class="word-content">
                            <div class="word-header">
                                <span class="word-word">${item.word}</span>
                                <button class="audio-btn" onclick="speakWord('${item.word}')">ğŸ”Š</button>
                            </div>
                            <div class="word-meaning">
                                <div class="word-meaning-cn">${cnText}</div>
                                <div style="color:#888; font-size:13px;">${enText}</div>
                            </div>
                        </div>
                        <div class="action-btns">
                            <button class="icon-btn" onclick="editWord('${archive}', '${item.word}')">âœï¸</button>
                            <button class="icon-btn danger" onclick="deleteWord('${archive}', '${item.word}')">ğŸ—‘ï¸</button>
                        </div>
                    `;
                    groupDiv.appendChild(wordDiv);
                });
                vocabListDisplay.appendChild(groupDiv);
            });
        }

        renderVocabList();
    </script>
</body>
</html>
