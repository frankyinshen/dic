<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¯­éŸ³æ‹¼å†™ç”Ÿè¯æœ¬ v2.3.0</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; max-width: 500px; margin: 0 auto; padding: 20px; background: #f4f7f6; color: #333; }
        .card { background: white; padding: 25px 20px; border-radius: 16px; box-shadow: 0 8px 20px rgba(0,0,0,0.06); margin-bottom: 20px; text-align: center; }
        h2 { margin-top: 0; font-size: 20px; color: #1c1c1e; display: flex; justify-content: space-between; align-items: center;}
        .version-tag { font-size: 12px; background: #000; padding: 3px 10px; border-radius: 12px; color: #ffd700; font-weight: bold; letter-spacing: 0.5px;}
        
        #recordBtn { background: #007aff; color: white; border: none; padding: 18px 30px; font-size: 18px; font-weight: 600; border-radius: 50px; cursor: pointer; user-select: none; transition: all 0.2s; width: 100%; box-shadow: 0 4px 12px rgba(0,122,255,0.3); -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent;}
        
        /* æŒ‰ä¸‹å½•éŸ³æ—¶çš„çŠ¶æ€ */
        #recordBtn.recording { background: #ff3b30; box-shadow: 0 4px 12px rgba(255,59,48,0.4); transform: scale(0.96); }
        /* æ¾å¼€æ‰‹ï¼Œç­‰å¾…è‹¹æœæœåŠ¡å™¨æ—¶çš„ç¼“å†²çŠ¶æ€ */
        #recordBtn.busy { background: #ff9500; box-shadow: 0 4px 12px rgba(255,149,0,0.4); pointer-events: none; transform: none; }

        #exportBtn { background: #34c759; color: white; border: none; padding: 8px 15px; font-size: 14px; font-weight: 600; border-radius: 8px; cursor: pointer; transition: opacity 0.2s; }
        #exportBtn:active { opacity: 0.7; }

        .status { margin-top: 15px; font-size: 14px; color: #8e8e93; min-height: 20px; font-weight: 500; }
        #rawTranscript { margin-top: 8px; font-size: 13px; color: #ff9500; display: block; min-height: 15px; font-weight: bold;}
        #resultWord { font-size: 40px; font-weight: 800; margin: 15px 0; color: #1c1c1e; letter-spacing: 2px; }
        #meaning { font-size: 15px; color: #3a3a3c; min-height: 45px; background: #f2f2f7; padding: 12px; border-radius: 12px; line-height: 1.5;}
        
        .input-group { text-align: left; margin-bottom: 20px; }
        label { font-size: 14px; font-weight: 600; color: #636366; display: block; margin-bottom: 8px; }
        input[type="text"] { width: 100%; padding: 12px; border: 1px solid #d1d1d6; border-radius: 10px; box-sizing: border-box; font-size: 16px; outline: none; }
        
        .word-list { text-align: left; }
        .archive-group { margin-top: 20px; }
        .archive-header { background: #f2f2f7; padding: 10px 15px; border-radius: 10px; font-weight: 700; font-size: 15px; color: #1c1c1e; display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;}
        .word-item { padding: 12px 10px; border-bottom: 1px solid #e5e5ea; display: flex; flex-direction: column;}
        .word-item:last-child { border-bottom: none; }
        .word-word { font-size: 18px; font-weight: 700; color: #007aff; }
        .word-meaning { font-size: 14px; color: #636366; margin-top: 6px; }
    </style>
</head>
<body>

    <div class="card">
        <h2>
            ğŸ™ï¸ æŒ‰ä½è¯»å­—æ¯æ‹¼å†™
            <span class="version-tag">v2.3.0-Ultra</span>
        </h2>
        
        <div class="input-group">
            <label for="archiveName">å½’æ¡£åç§° (å¯ä¿®æ”¹ä¸ºä¹¦å/ç« èŠ‚):</label>
            <input type="text" id="archiveName" placeholder="ä¾‹å¦‚: 2026-02-20 æˆ– ç®€çˆ±-ç¬¬ä¸€ç« ">
        </div>

        <button id="recordBtn">æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯</button>
        <div class="status" id="statusText">å‡†å¤‡å°±ç»ª...</div>
        <div id="rawTranscript"></div>
        
        <div id="resultWord">...</div>
        <div id="meaning">ç­‰å¾…æŸ¥è¯...</div>
    </div>

    <div class="card word-list">
        <h2>
            ğŸ“š ä½ çš„ç”Ÿè¯æœ¬
            <button id="exportBtn">ğŸ’¾ å¯¼å‡º CSV</button>
        </h2>
        <div id="vocabList"></div>
    </div>

    <script>
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('archiveName').value = today;

        const recordBtn = document.getElementById('recordBtn');
        const exportBtn = document.getElementById('exportBtn');
        const statusText = document.getElementById('statusText');
        const rawTranscriptDisplay = document.getElementById('rawTranscript');
        const resultWordDisplay = document.getElementById('resultWord');
        const meaningDisplay = document.getElementById('meaning');
        const vocabListDisplay = document.getElementById('vocabList');

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;
        
        let isSystemBusy = false; 
        let fallbackTimer = null; 

        // å½»åº•æ¸…ç†æ—§å®ä¾‹ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼å’Œé‡å 
        function resetRecognition() {
            if (recognition) {
                recognition.onstart = null;
                recognition.onresult = null;
                recognition.onerror = null;
                recognition.onend = null;
                try { recognition.abort(); } catch(e){}
                recognition = null;
            }
            clearTimeout(fallbackTimer);
        }

        // 1. æŒ‰ä¸‹æŒ‰é’®ï¼šåˆ›å»ºæ–°é€šé“ï¼Œå¼€å§‹å½•éŸ³
        const startRecording = (e) => {
            e.preventDefault();
            
            // å¦‚æœä¸Šä¸€ä¸ªè¯è¿˜åœ¨å¤„ç†ï¼Œå¿½ç•¥ç‚¹å‡»
            if (isSystemBusy) return; 
            
            isSystemBusy = true;
            rawTranscriptDisplay.innerText = "";
            resetRecognition();

            if (!SpeechRecognition) {
                statusText.innerText = "âŒ æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«ã€‚";
                isSystemBusy = false;
                return;
            }

            recognition = new SpeechRecognition();
            recognition.lang = 'en-US'; 
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;
            recognition.continuous = false;

            recognition.onstart = () => {
                recordBtn.classList.add('recording');
                recordBtn.innerText = "ğŸ›‘ æ­£åœ¨è†å¬... (è¯·è¯´å®Œå†æ¾æ‰‹)";
                statusText.innerText = "è¯·å¼€å§‹æ‹¼è¯»å­—æ¯...";
            };

            recognition.onresult = async (event) => {
                clearTimeout(fallbackTimer); // æˆåŠŸæ‹¿åˆ°ç»“æœï¼Œå–æ¶ˆå¼ºæ€å®šæ—¶å™¨

                const transcript = event.results[0][0].transcript;
                rawTranscriptDisplay.innerText = `[è‹¹æœæœåŠ¡å™¨è¿”å›]: "${transcript}"`;
                
                const word = transcript.replace(/[^a-zA-Z]/g, '').toLowerCase();
                
                if (!word) {
                    statusText.innerText = "âš ï¸ è¯†åˆ«ç»“æœä¸­ä¸åŒ…å«è‹±æ–‡å­—æ¯ã€‚";
                    return;
                }

                resultWordDisplay.innerText = word;
                statusText.innerText = "æ­£åœ¨æŸ¥è¯¢å­—å…¸...";
                await processWord(word);
            };

            recognition.onerror = (event) => {
                clearTimeout(fallbackTimer);
                console.error("è¯†åˆ«é”™è¯¯:", event.error);
                const errorMap = {
                    'network': "ç½‘ç»œä¸ä½³ï¼Œæ— æ³•è¿æ¥è‹¹æœæœåŠ¡å™¨ã€‚",
                    'not-allowed': "è¯·åœ¨ Safari è®¾ç½®ä¸­å…è®¸éº¦å…‹é£æƒé™ã€‚",
                    'no-speech': "æ²¡å¬åˆ°å£°éŸ³ï¼Œè¯·å¤§ç‚¹å£°å‘éŸ³ã€‚",
                    'service-not-allowed': "è¯·åœ¨ç³»ç»Ÿã€è®¾ç½®-é€šç”¨-é”®ç›˜-å¯ç”¨å¬å†™ã€‘ä¸­å¼€å¯ã€‚",
                    'aborted': "è¯†åˆ«è¢«å¼ºåˆ¶ä¸­æ–­ã€‚"
                };
                statusText.innerText = "âŒ é”™è¯¯: " + (errorMap[event.error] || event.error);
            };

            recognition.onend = () => {
                clearTimeout(fallbackTimer);
                isSystemBusy = false; // å½»åº•è§£é™¤é”å®š
                
                // æ¢å¤æŒ‰é’®åˆå§‹è“è‰²çŠ¶æ€
                recordBtn.classList.remove('busy');
                recordBtn.classList.remove('recording');
                recordBtn.innerText = "æŒ‰ä½å¼€å§‹æ‹¼å†™å­—æ¯";

                // å¦‚æœæ¾æ‰‹åï¼Œè‹¹æœä¾ç„¶ä»€ä¹ˆéƒ½æ²¡è¿”å›ï¼Œç»™å‡ºç²¾å‡†æç¤º
                if(statusText.innerText === "å·²æ¾å¼€ï¼Œç­‰å¾…è‹¹æœæœåŠ¡å™¨å›ä¼ æ•°æ®...") {
                    statusText.innerText = "âš ï¸ æœåŠ¡å™¨æœªè¿”å›æ•°æ®ï¼Œå¯èƒ½æ˜¯è¯»å¤ªå¿«æˆ–ç½‘ç»œå¡é¡¿ï¼Œè¯·é‡è¯•ã€‚";
                }
            };

            try {
                recognition.start();
            } catch (err) {
                isSystemBusy = false;
                statusText.innerText = "å¯åŠ¨éº¦å…‹é£å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚";
            }
        };

        // 2. æ¾å¼€æ‰‹æŒ‡ï¼šä¸ç«‹åˆ»å¼ºæ€ï¼Œç»™æœåŠ¡å™¨æ—¶é—´ç¼“å†²
        const stopRecording = (e) => {
            e.preventDefault();
            
            if (!isSystemBusy) return; 

            // ã€æ ¸å¿ƒä¿®å¤ã€‘ï¼šä¸è¦åœ¨è¿™é‡Œè°ƒç”¨ recognition.stop()ï¼
            // æŠŠæŒ‰é’®å˜æˆæ©˜é»„è‰²ï¼Œå‘Šè¯‰ç”¨æˆ·æ­£åœ¨å¤„ç†ä¸­ã€‚
            recordBtn.classList.remove('recording');
            recordBtn.classList.add('busy');
            recordBtn.innerText = "â³ æ¥æ”¶ç»“æœä¸­...";
            statusText.innerText = "å·²æ¾å¼€ï¼Œç­‰å¾…è‹¹æœæœåŠ¡å™¨å›ä¼ æ•°æ®...";

            // ä¿æŠ¤æœºåˆ¶ï¼šç»™è‹¹æœæœåŠ¡å™¨æœ€å¤š 2.5 ç§’é’Ÿã€‚
            // 2.5 ç§’åå¦‚æœè¿˜æ²¡å‡ºç»“æœï¼Œä¸ºäº†é˜²æ­¢å¡æ­»ï¼Œå†æ‰‹åŠ¨å¼ºæ€ã€‚
            fallbackTimer = setTimeout(() => {
                if (isSystemBusy && recognition) {
                    try { recognition.stop(); } catch(err) {}
                }
            }, 2500); 
        };

        // ç»‘å®šäº‹ä»¶
        recordBtn.addEventListener('mousedown', startRecording);
        recordBtn.addEventListener('touchstart', startRecording, {passive: false});
        
        recordBtn.addEventListener('mouseup', stopRecording);
        recordBtn.addEventListener('touchend', stopRecording);
        recordBtn.addEventListener('mouseleave', stopRecording);
        recordBtn.addEventListener('touchcancel', stopRecording);

        // å¤„ç†å•è¯å’Œç¼“å­˜é€»è¾‘
        async function processWord(word) {
            let meaning = "æš‚æ— é‡Šä¹‰ã€‚";
            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (response.ok) {
                    const data = await response.json();
                    meaning = data[0].meanings[0].definitions[0].definition;
                    statusText.innerText = "âœ… æŸ¥è¯¢æˆåŠŸï¼";
                } else {
                    statusText.innerText = "âš ï¸ å­—å…¸ä¸­æœªæ‰¾åˆ°è¯¥è¯ã€‚";
                }
            } catch (error) {
                meaning = "ç½‘ç»œé”™è¯¯ï¼ŒæŸ¥è¯å¤±è´¥ã€‚";
                statusText.innerText = "âŒ æŸ¥è¯ç½‘ç»œå¼‚å¸¸";
            }

            meaningDisplay.innerText = meaning;
            saveWord(word, meaning);
            renderVocabList();
        }

        function saveWord(word, meaning) {
            const archiveName = document.getElementById('archiveName').value || today;
            let vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if (!vocabData[archiveName]) vocabData[archiveName] = [];
            const exists = vocabData[archiveName].find(w => w.word === word);
            if (!exists) {
                vocabData[archiveName].unshift({ word, meaning });
                localStorage.setItem('myVocabBook', JSON.stringify(vocabData));
            }
        }

        function renderVocabList() {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            vocabListDisplay.innerHTML = '';
            for (const archive in vocabData) {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'archive-group';
                const header = document.createElement('div');
                header.className = 'archive-header';
                header.innerHTML = `<span>ğŸ“‚ ${archive}</span> <span style="font-size: 13px; color: #8e8e93; font-weight: normal;">${vocabData[archive].length} è¯</span>`;
                groupDiv.appendChild(header);
                vocabData[archive].forEach(item => {
                    const wordDiv = document.createElement('div');
                    wordDiv.className = 'word-item';
                    wordDiv.innerHTML = `<span class="word-word">${item.word}</span><span class="word-meaning">${item.meaning}</span>`;
                    groupDiv.appendChild(wordDiv);
                });
                vocabListDisplay.appendChild(groupDiv);
            }
        }

        exportBtn.addEventListener('click', () => {
            const vocabData = JSON.parse(localStorage.getItem('myVocabBook')) || {};
            if (Object.keys(vocabData).length === 0) {
                alert("ç”Ÿè¯æœ¬æ˜¯ç©ºçš„ï¼"); return;
            }
            let csvContent = "\uFEFFå½’æ¡£åç§°,å•è¯,é‡Šä¹‰\n";
            for (const archive in vocabData) {
                vocabData[archive].forEach(item => {
                    let safeMeaning = item.meaning.replace(/"/g, '""');
                    csvContent += `"${archive}","${item.word}","${safeMeaning}"\n`;
                });
            }
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            link.setAttribute("download", `ç”Ÿè¯æœ¬_${today}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        renderVocabList();
    </script>
</body>
</html>
